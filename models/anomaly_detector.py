"""
PIL Protocol - Anomaly Detection Model
Off-chain ML model for transaction pattern analysis and threat detection

Author: PIL Protocol Team
Date: January 2026
"""

import numpy as np
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Tuple
from enum import Enum
from collections import deque
import json
import hashlib
from datetime import datetime, timedelta


class AnomalyType(Enum):
    """Types of detectable anomalies"""
    NORMAL = 0
    UNUSUAL_VOLUME = 1
    TIMING_ANOMALY = 2
    ADDRESS_CLUSTERING = 3
    FLASH_LOAN_PATTERN = 4
    SANDWICH_ATTACK = 5
    ORACLE_MANIPULATION = 6
    WASH_TRADING = 7
    SYBIL_ATTACK = 8
    BRIDGE_EXPLOIT = 9
    MEV_EXTRACTION = 10


class RiskLevel(Enum):
    """Risk classification levels"""
    SAFE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    CRITICAL = 4


@dataclass
class Transaction:
    """Transaction data structure"""
    tx_hash: str
    sender: str
    recipient: str
    value: float
    gas_used: int
    gas_price: float
    block_number: int
    timestamp: int
    method_id: str
    is_bridge: bool = False
    source_chain: int = 1
    dest_chain: int = 1
    proof_hash: Optional[str] = None


@dataclass
class AnomalyAlert:
    """Alert generated by anomaly detection"""
    alert_id: str
    anomaly_type: AnomalyType
    risk_level: RiskLevel
    confidence: float
    transactions: List[str]
    description: str
    timestamp: int
    metadata: Dict = field(default_factory=dict)


@dataclass
class AddressProfile:
    """Behavioral profile for an address"""
    address: str
    total_volume: float = 0.0
    tx_count: int = 0
    avg_value: float = 0.0
    avg_gas: float = 0.0
    first_seen: int = 0
    last_seen: int = 0
    unique_counterparties: int = 0
    bridge_count: int = 0
    failure_rate: float = 0.0
    risk_score: float = 0.0


class StatisticalDetector:
    """Statistical anomaly detection using Z-scores and IQR"""
    
    def __init__(self, window_size: int = 1000):
        self.window_size = window_size
        self.volume_history = deque(maxlen=window_size)
        self.gas_history = deque(maxlen=window_size)
        self.timing_history = deque(maxlen=window_size)
        
    def update(self, tx: Transaction):
        """Update historical data with new transaction"""
        self.volume_history.append(tx.value)
        self.gas_history.append(tx.gas_used)
        if len(self.timing_history) > 0:
            self.timing_history.append(tx.timestamp - self.timing_history[-1])
        else:
            self.timing_history.append(0)
    
    def calculate_z_score(self, value: float, history: deque) -> float:
        """Calculate Z-score for a value"""
        if len(history) < 10:
            return 0.0
        
        arr = np.array(list(history))
        mean = np.mean(arr)
        std = np.std(arr)
        
        if std == 0:
            return 0.0
        
        return (value - mean) / std
    
    def detect_volume_anomaly(self, tx: Transaction) -> Tuple[bool, float]:
        """Detect unusual transaction volume"""
        z_score = self.calculate_z_score(tx.value, self.volume_history)
        is_anomaly = abs(z_score) > 3.0
        return is_anomaly, abs(z_score) / 5.0  # Normalize confidence
    
    def detect_timing_anomaly(self, tx: Transaction) -> Tuple[bool, float]:
        """Detect unusual transaction timing"""
        if len(self.timing_history) < 2:
            return False, 0.0
        
        current_gap = tx.timestamp - list(self.timing_history)[-1]
        z_score = self.calculate_z_score(current_gap, self.timing_history)
        
        # Very fast transactions might indicate automation/bots
        is_anomaly = abs(z_score) > 2.5 or current_gap < 2
        return is_anomaly, min(abs(z_score) / 4.0, 1.0)


class PatternDetector:
    """Pattern-based anomaly detection"""
    
    def __init__(self):
        self.recent_txs: deque = deque(maxlen=100)
        self.address_pairs: Dict[str, int] = {}
        self.block_activity: Dict[int, List[Transaction]] = {}
    
    def add_transaction(self, tx: Transaction):
        """Add transaction for pattern analysis"""
        self.recent_txs.append(tx)
        
        pair_key = f"{tx.sender}_{tx.recipient}"
        self.address_pairs[pair_key] = self.address_pairs.get(pair_key, 0) + 1
        
        if tx.block_number not in self.block_activity:
            self.block_activity[tx.block_number] = []
        self.block_activity[tx.block_number].append(tx)
    
    def detect_flash_loan_pattern(self, tx: Transaction) -> Tuple[bool, float]:
        """Detect flash loan attack patterns"""
        if tx.block_number not in self.block_activity:
            return False, 0.0
        
        block_txs = self.block_activity[tx.block_number]
        
        # Check for same-block round-trip
        sender_txs = [t for t in block_txs if t.sender == tx.sender]
        if len(sender_txs) < 2:
            return False, 0.0
        
        # Large value + multiple txs in same block = suspicious
        total_value = sum(t.value for t in sender_txs)
        if total_value > 1000 and len(sender_txs) >= 3:
            return True, 0.8
        
        return False, 0.0
    
    def detect_sandwich_attack(self, tx: Transaction) -> Tuple[bool, float]:
        """Detect sandwich attack patterns"""
        if tx.block_number not in self.block_activity:
            return False, 0.0
        
        block_txs = self.block_activity[tx.block_number]
        
        # Look for frontrun-victim-backrun pattern
        for i, t1 in enumerate(block_txs[:-2]):
            if t1.method_id != tx.method_id:
                continue
            
            for j, t2 in enumerate(block_txs[i+1:-1]):
                if t2.sender == tx.sender:
                    continue
                
                for t3 in block_txs[i+j+2:]:
                    if t3.sender == t1.sender and t3.method_id == t1.method_id:
                        # Potential sandwich: same sender wraps different tx
                        return True, 0.85
        
        return False, 0.0
    
    def detect_wash_trading(self, tx: Transaction) -> Tuple[bool, float]:
        """Detect wash trading patterns"""
        pair_key = f"{tx.sender}_{tx.recipient}"
        reverse_key = f"{tx.recipient}_{tx.sender}"
        
        forward_count = self.address_pairs.get(pair_key, 0)
        reverse_count = self.address_pairs.get(reverse_key, 0)
        
        # High bidirectional activity is suspicious
        if forward_count > 5 and reverse_count > 5:
            ratio = min(forward_count, reverse_count) / max(forward_count, reverse_count)
            if ratio > 0.7:  # Nearly equal back-and-forth
                return True, ratio
        
        return False, 0.0
    
    def detect_sybil_pattern(self, tx: Transaction, profiles: Dict[str, AddressProfile]) -> Tuple[bool, float]:
        """Detect Sybil attack patterns"""
        sender_profile = profiles.get(tx.sender)
        if not sender_profile:
            return False, 0.0
        
        # New address with high activity is suspicious
        age_hours = (tx.timestamp - sender_profile.first_seen) / 3600
        if age_hours < 24 and sender_profile.tx_count > 50:
            return True, 0.7
        
        # Low unique counterparties relative to tx count
        if sender_profile.tx_count > 20:
            diversity = sender_profile.unique_counterparties / sender_profile.tx_count
            if diversity < 0.1:
                return True, 0.6
        
        return False, 0.0


class BridgeAnomalyDetector:
    """Specialized detector for cross-chain bridge anomalies"""
    
    def __init__(self):
        self.pending_bridges: Dict[str, Transaction] = {}
        self.completed_bridges: Dict[str, Tuple[Transaction, Transaction]] = {}
        self.chain_volumes: Dict[int, float] = {}
        self.proof_registry: Dict[str, int] = {}  # proof_hash -> count
    
    def track_bridge_initiation(self, tx: Transaction):
        """Track outgoing bridge transaction"""
        if not tx.is_bridge or not tx.proof_hash:
            return
        
        self.pending_bridges[tx.proof_hash] = tx
        self.chain_volumes[tx.source_chain] = self.chain_volumes.get(tx.source_chain, 0) + tx.value
        self.proof_registry[tx.proof_hash] = self.proof_registry.get(tx.proof_hash, 0) + 1
    
    def track_bridge_completion(self, tx: Transaction) -> Optional[AnomalyAlert]:
        """Track incoming bridge transaction and check for anomalies"""
        if not tx.is_bridge or not tx.proof_hash:
            return None
        
        # Check for double-spend attempt
        if self.proof_registry.get(tx.proof_hash, 0) > 1:
            return AnomalyAlert(
                alert_id=self._generate_alert_id(tx),
                anomaly_type=AnomalyType.BRIDGE_EXPLOIT,
                risk_level=RiskLevel.CRITICAL,
                confidence=0.95,
                transactions=[tx.tx_hash],
                description=f"Potential double-spend: proof {tx.proof_hash} used {self.proof_registry[tx.proof_hash]} times",
                timestamp=tx.timestamp,
                metadata={"proof_hash": tx.proof_hash}
            )
        
        # Check for value mismatch
        if tx.proof_hash in self.pending_bridges:
            original = self.pending_bridges[tx.proof_hash]
            if abs(original.value - tx.value) > original.value * 0.01:  # >1% difference
                return AnomalyAlert(
                    alert_id=self._generate_alert_id(tx),
                    anomaly_type=AnomalyType.BRIDGE_EXPLOIT,
                    risk_level=RiskLevel.HIGH,
                    confidence=0.8,
                    transactions=[original.tx_hash, tx.tx_hash],
                    description=f"Value mismatch: sent {original.value}, received {tx.value}",
                    timestamp=tx.timestamp
                )
        
        return None
    
    def detect_bridge_drain(self) -> Optional[AnomalyAlert]:
        """Detect potential bridge drain attack"""
        total_pending = sum(tx.value for tx in self.pending_bridges.values())
        
        for chain_id, volume in self.chain_volumes.items():
            if volume > total_pending * 2:  # Outflow > 2x inflow
                return AnomalyAlert(
                    alert_id=hashlib.sha256(f"drain_{chain_id}_{datetime.now()}".encode()).hexdigest()[:16],
                    anomaly_type=AnomalyType.BRIDGE_EXPLOIT,
                    risk_level=RiskLevel.CRITICAL,
                    confidence=0.9,
                    transactions=[],
                    description=f"Potential bridge drain on chain {chain_id}: volume {volume}",
                    timestamp=int(datetime.now().timestamp()),
                    metadata={"chain_id": chain_id, "volume": volume}
                )
        
        return None
    
    def _generate_alert_id(self, tx: Transaction) -> str:
        return hashlib.sha256(f"{tx.tx_hash}_{tx.timestamp}".encode()).hexdigest()[:16]


class TransactionAnomalyDetector:
    """
    Main anomaly detection system combining multiple detection strategies
    """
    
    def __init__(self, config: Optional[Dict] = None):
        self.config = config or self._default_config()
        
        self.statistical_detector = StatisticalDetector(
            window_size=self.config.get("window_size", 1000)
        )
        self.pattern_detector = PatternDetector()
        self.bridge_detector = BridgeAnomalyDetector()
        
        self.address_profiles: Dict[str, AddressProfile] = {}
        self.alerts: List[AnomalyAlert] = []
        self.alert_history: deque = deque(maxlen=10000)
        
        # Thresholds
        self.confidence_threshold = self.config.get("confidence_threshold", 0.7)
        self.auto_escalate_threshold = self.config.get("auto_escalate_threshold", 0.9)
    
    def _default_config(self) -> Dict:
        return {
            "window_size": 1000,
            "confidence_threshold": 0.7,
            "auto_escalate_threshold": 0.9,
            "enable_ml_features": True,
            "alert_cooldown_seconds": 60
        }
    
    def process_transaction(self, tx: Transaction) -> List[AnomalyAlert]:
        """Process a transaction and return any anomaly alerts"""
        alerts = []
        
        # Update address profile
        self._update_address_profile(tx)
        
        # Update detectors
        self.statistical_detector.update(tx)
        self.pattern_detector.add_transaction(tx)
        
        # Run detection strategies
        alerts.extend(self._run_statistical_detection(tx))
        alerts.extend(self._run_pattern_detection(tx))
        
        if tx.is_bridge:
            self.bridge_detector.track_bridge_initiation(tx)
            bridge_alert = self.bridge_detector.track_bridge_completion(tx)
            if bridge_alert:
                alerts.append(bridge_alert)
        
        # Filter by confidence threshold
        alerts = [a for a in alerts if a.confidence >= self.confidence_threshold]
        
        # Store alerts
        for alert in alerts:
            self.alerts.append(alert)
            self.alert_history.append(alert)
        
        return alerts
    
    def _update_address_profile(self, tx: Transaction):
        """Update behavioral profile for sender"""
        if tx.sender not in self.address_profiles:
            self.address_profiles[tx.sender] = AddressProfile(
                address=tx.sender,
                first_seen=tx.timestamp
            )
        
        profile = self.address_profiles[tx.sender]
        profile.total_volume += tx.value
        profile.tx_count += 1
        profile.avg_value = profile.total_volume / profile.tx_count
        profile.avg_gas = (profile.avg_gas * (profile.tx_count - 1) + tx.gas_used) / profile.tx_count
        profile.last_seen = tx.timestamp
        
        if tx.is_bridge:
            profile.bridge_count += 1
    
    def _run_statistical_detection(self, tx: Transaction) -> List[AnomalyAlert]:
        """Run statistical anomaly detection"""
        alerts = []
        
        # Volume anomaly
        is_volume_anomaly, vol_confidence = self.statistical_detector.detect_volume_anomaly(tx)
        if is_volume_anomaly:
            alerts.append(AnomalyAlert(
                alert_id=self._generate_alert_id("volume", tx),
                anomaly_type=AnomalyType.UNUSUAL_VOLUME,
                risk_level=self._confidence_to_risk(vol_confidence),
                confidence=vol_confidence,
                transactions=[tx.tx_hash],
                description=f"Unusual transaction volume: {tx.value}",
                timestamp=tx.timestamp
            ))
        
        # Timing anomaly
        is_timing_anomaly, timing_confidence = self.statistical_detector.detect_timing_anomaly(tx)
        if is_timing_anomaly:
            alerts.append(AnomalyAlert(
                alert_id=self._generate_alert_id("timing", tx),
                anomaly_type=AnomalyType.TIMING_ANOMALY,
                risk_level=self._confidence_to_risk(timing_confidence),
                confidence=timing_confidence,
                transactions=[tx.tx_hash],
                description="Unusual transaction timing pattern",
                timestamp=tx.timestamp
            ))
        
        return alerts
    
    def _run_pattern_detection(self, tx: Transaction) -> List[AnomalyAlert]:
        """Run pattern-based detection"""
        alerts = []
        
        # Flash loan
        is_flash, flash_conf = self.pattern_detector.detect_flash_loan_pattern(tx)
        if is_flash:
            alerts.append(AnomalyAlert(
                alert_id=self._generate_alert_id("flash", tx),
                anomaly_type=AnomalyType.FLASH_LOAN_PATTERN,
                risk_level=RiskLevel.HIGH,
                confidence=flash_conf,
                transactions=[tx.tx_hash],
                description="Potential flash loan attack pattern detected",
                timestamp=tx.timestamp
            ))
        
        # Sandwich
        is_sandwich, sandwich_conf = self.pattern_detector.detect_sandwich_attack(tx)
        if is_sandwich:
            alerts.append(AnomalyAlert(
                alert_id=self._generate_alert_id("sandwich", tx),
                anomaly_type=AnomalyType.SANDWICH_ATTACK,
                risk_level=RiskLevel.HIGH,
                confidence=sandwich_conf,
                transactions=[tx.tx_hash],
                description="Potential sandwich attack detected",
                timestamp=tx.timestamp
            ))
        
        # Wash trading
        is_wash, wash_conf = self.pattern_detector.detect_wash_trading(tx)
        if is_wash:
            alerts.append(AnomalyAlert(
                alert_id=self._generate_alert_id("wash", tx),
                anomaly_type=AnomalyType.WASH_TRADING,
                risk_level=RiskLevel.MEDIUM,
                confidence=wash_conf,
                transactions=[tx.tx_hash],
                description="Potential wash trading detected",
                timestamp=tx.timestamp
            ))
        
        # Sybil
        is_sybil, sybil_conf = self.pattern_detector.detect_sybil_pattern(tx, self.address_profiles)
        if is_sybil:
            alerts.append(AnomalyAlert(
                alert_id=self._generate_alert_id("sybil", tx),
                anomaly_type=AnomalyType.SYBIL_ATTACK,
                risk_level=RiskLevel.MEDIUM,
                confidence=sybil_conf,
                transactions=[tx.tx_hash],
                description="Potential Sybil attack pattern",
                timestamp=tx.timestamp
            ))
        
        return alerts
    
    def _generate_alert_id(self, prefix: str, tx: Transaction) -> str:
        return hashlib.sha256(f"{prefix}_{tx.tx_hash}_{tx.timestamp}".encode()).hexdigest()[:16]
    
    def _confidence_to_risk(self, confidence: float) -> RiskLevel:
        if confidence >= 0.9:
            return RiskLevel.CRITICAL
        elif confidence >= 0.7:
            return RiskLevel.HIGH
        elif confidence >= 0.5:
            return RiskLevel.MEDIUM
        elif confidence >= 0.3:
            return RiskLevel.LOW
        return RiskLevel.SAFE
    
    def get_address_risk_score(self, address: str) -> float:
        """Calculate risk score for an address"""
        if address not in self.address_profiles:
            return 0.0
        
        profile = self.address_profiles[address]
        
        # Factors that increase risk
        score = 0.0
        
        # New address with high activity
        age_days = (profile.last_seen - profile.first_seen) / 86400
        if age_days < 1 and profile.tx_count > 20:
            score += 0.3
        
        # High failure rate
        score += profile.failure_rate * 0.2
        
        # Unusual average value
        if profile.avg_value > 100:
            score += 0.1
        
        # High bridge activity relative to total
        if profile.tx_count > 0:
            bridge_ratio = profile.bridge_count / profile.tx_count
            if bridge_ratio > 0.8:
                score += 0.2
        
        return min(score, 1.0)
    
    def flag_suspicious_activity(self, score_threshold: float = 0.8) -> List[str]:
        """Get list of suspicious addresses above threshold"""
        suspicious = []
        for address, profile in self.address_profiles.items():
            risk = self.get_address_risk_score(address)
            if risk >= score_threshold:
                suspicious.append(address)
        return suspicious
    
    def generate_forensic_report(self) -> Dict:
        """Generate forensic report for security review"""
        return {
            "generated_at": datetime.now().isoformat(),
            "total_transactions_analyzed": sum(p.tx_count for p in self.address_profiles.values()),
            "unique_addresses": len(self.address_profiles),
            "total_alerts": len(self.alerts),
            "alerts_by_type": self._count_alerts_by_type(),
            "alerts_by_risk": self._count_alerts_by_risk(),
            "high_risk_addresses": self.flag_suspicious_activity(0.7),
            "recent_critical_alerts": [
                self._alert_to_dict(a) for a in self.alerts 
                if a.risk_level == RiskLevel.CRITICAL
            ][-10:],
            "bridge_statistics": {
                "pending_bridges": len(self.bridge_detector.pending_bridges),
                "completed_bridges": len(self.bridge_detector.completed_bridges),
                "chain_volumes": self.bridge_detector.chain_volumes
            }
        }
    
    def _count_alerts_by_type(self) -> Dict[str, int]:
        counts = {}
        for alert in self.alerts:
            type_name = alert.anomaly_type.name
            counts[type_name] = counts.get(type_name, 0) + 1
        return counts
    
    def _count_alerts_by_risk(self) -> Dict[str, int]:
        counts = {}
        for alert in self.alerts:
            risk_name = alert.risk_level.name
            counts[risk_name] = counts.get(risk_name, 0) + 1
        return counts
    
    def _alert_to_dict(self, alert: AnomalyAlert) -> Dict:
        return {
            "alert_id": alert.alert_id,
            "type": alert.anomaly_type.name,
            "risk": alert.risk_level.name,
            "confidence": alert.confidence,
            "description": alert.description,
            "transactions": alert.transactions,
            "timestamp": alert.timestamp
        }


# Example usage and testing
if __name__ == "__main__":
    # Initialize detector
    detector = TransactionAnomalyDetector()
    
    # Simulate some transactions
    test_txs = [
        Transaction(
            tx_hash="0x1234",
            sender="0xAlice",
            recipient="0xBob",
            value=1.0,
            gas_used=21000,
            gas_price=20.0,
            block_number=1000,
            timestamp=1705900000,
            method_id="0xa9059cbb"
        ),
        Transaction(
            tx_hash="0x5678",
            sender="0xAlice",
            recipient="0xCharlie",
            value=1000.0,  # Unusual volume
            gas_used=100000,
            gas_price=50.0,
            block_number=1001,
            timestamp=1705900012,
            method_id="0xa9059cbb"
        ),
        Transaction(
            tx_hash="0x9abc",
            sender="0xMalicious",
            recipient="0xBridge",
            value=500.0,
            gas_used=200000,
            gas_price=100.0,
            block_number=1001,
            timestamp=1705900012,
            method_id="0x12345678",
            is_bridge=True,
            source_chain=1,
            dest_chain=42161,
            proof_hash="0xproof123"
        ),
    ]
    
    print("=== PIL Anomaly Detection Test ===\n")
    
    for tx in test_txs:
        alerts = detector.process_transaction(tx)
        if alerts:
            print(f"Transaction {tx.tx_hash}:")
            for alert in alerts:
                print(f"  ⚠️  {alert.anomaly_type.name}: {alert.description}")
                print(f"      Risk: {alert.risk_level.name}, Confidence: {alert.confidence:.2f}")
            print()
    
    # Generate report
    report = detector.generate_forensic_report()
    print("\n=== Forensic Report ===")
    print(json.dumps(report, indent=2, default=str))
